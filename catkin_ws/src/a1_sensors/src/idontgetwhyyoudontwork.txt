#include <iostream>
#include "arm_controller.h"
#include "ros/ros.h"
#include <sensor_msgs/JointState.h>
#include <moveit/move_group_interface/move_group_interface.h>

ArmController::ArmController(ros::NodeHandle nh) : nh_(nh) {
    // Initialize MoveIt
    move_arm_ = std::make_unique<moveit::planning_interface::MoveGroupInterface>("arm");
    // Initialize MoveIt for the base group
    //move_base_ = std::make_unique<moveit::planning_interface::MoveGroupInterface>("base");
    // Set a lower planning time to make planning faster (adjust as needed)
    move_arm_->setPlanningTime(5.0);

    // Subscribe to joint_states topic to receive current joint positions
    joint_state_sub_ = nh_.subscribe("/joint_states", 1, &ArmController::jointStateCallback, this);

    // Create a publisher to send joint position commands
    joint_command_pub_ = nh_.advertise<sensor_msgs::JointState>("/joint_commands", 1);
    // Create a publisher for sending velocity commands
    velocity_pub = nh.advertise<geometry_msgs::Twist>("/cmd_vel", 10);
}

void ArmController::BaseControl(const std::string& action, double distance, double velocity){
    // ************************ BASE EXECUTION **********************//
    // Create a Twist message to specify linear and angular velocities
    geometry_msgs::Twist cmd_vel;

    if (action == "turn") {
        // Turn by 25 degrees (approximately)
        cmd_vel.linear.x = 0.0;
        cmd_vel.angular.z = velocity; // Angular velocity to turn
    }
    else if (action == "move") {
        // Move straight in the X direction
        cmd_vel.linear.x = velocity;  // Adjust linear velocity as needed
        cmd_vel.angular.z = 0.0;
    }
    else if (action == "stop") {
        // Stop the robot
        cmd_vel.linear.x = 0.0;
        cmd_vel.angular.z = 0.0;
    }

    velocity_pub.publish(cmd_vel);
}
void ArmController::separateThread() {


    ros::Rate loop_rate(5.0); // Set the rate at which you want to control the arm (adjust as needed)

    double x_distance = 21;  // Desired X distance (adjust as needed)
    double turn_distance = 10.0;  // Desired Y distance (adjust as needed)
    double turn_negdistance = 10.0; 
    bool base_cont_fin = false;
    while (ros::ok()) {
        if (!base_cont_fin) {
            if (turn_distance > 0) {
                BaseControl("turn", 10.0, 1.0); // Turn by 1 degree per cycle
                turn_distance -= 1.0;
            } else if (x_distance > 0) {
                BaseControl("move", 1.0, 3.0); // Move forward with 3.0 m/s velocity for 1 meter
                x_distance -= 1.0;
            } else if (turn_negdistance > 0) {
                BaseControl("turn", 1.0, -1.0); // Turn by -1 degree per cycle (negative direction)
                turn_negdistance -= 1.0;
            } else {
                BaseControl("stop", 0, 0); // Stop the robot
                base_cont_fin = true;  // All base movements are complete
            }
        }
        // ************************ ARM EXECUTION ********************** //
        if (base_cont_fin){
            move_arm_->setNamedTarget("start");

            // Plan and execute the motion

            /////// NOT WORKING ////////
            moveit::planning_interface::MoveGroupInterface::Plan my_plan;
            bool success = (move_arm_->plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);

            if (success) {
                //ROS_INFO("Planning and executing the motion...");
                move_arm_->move();
                //ROS_INFO("Motion executed successfully!");
            } else {
                ROS_ERROR("Failed to plan the motion.");
            }
        }
    }

        loop_rate.sleep();
}

void ArmController::jointStateCallback(const sensor_msgs::JointState::ConstPtr &msg) {
    // Process joint state data, e.g., print joint angles.
    for (size_t i = 0; i < msg->position.size(); ++i) {
        //ROS_INFO("Joint %zu: %f", i, msg->position[i]);
    }
}